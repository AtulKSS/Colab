# -*- coding: utf-8 -*-
"""Phython Basics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ydoCeO_ujs0sPRxxNwOLO5GVW_QGl4el
"""

print("hello world")

print('hello world')

var = print("hello world")
print(var) #Returns NONE

var2= 'Hello world'
print(var2) #prints a string

# ()=tuple
# {}=dictionary
# []=List
# > = Greater than
# < = Smaller than
# : = colan
# "" = writing statemnet for print or any other
# var= 56.7 its a floating point variable 
# type function = print(type(var))

# typecasting
# str()
# float()
# int()
var1 = "56"
var2 = "55"
print(int(var1)+ int(var2))
# print statement using * function
print(10* "hello\n")

# String slicing
strs= ".ecneics noitamrofni mutnauq dna ,ygolonhcet mutnauq ,yroeht dleif mutnauq ,yrtsimehc mutnauq gnidulcni scisyhp mutnauq lla fo noitadnuof eht si tI  1.1 :]2[.selcitrap cimotabus dna smota fo elacs eht ta erutan fo seitreporp lacisyhp eht fo noitpircsed a sedivorp taht scisyhp ni yroeht latnemadnuf a si scinahcem mutnauQ"
# print(strs[0:5])
# print(strs[::2]) #skips 2 characters
print(strs[::-1]) #Reverses the string 
print(strs.count("o")) #Counts Argument in string
print(strs.capitalize()) #ccapitalizes first letter for string
print(strs.find("is")) #Finds the givien world in imput string
print(strs.lower()) #Lower cases the given string
print(strs.upper()) #capitalizes every character in string
print(str.replace("dna","dma")) #Replaces new string with older
# TRUE and FALSE two boolean Characters
# Boolean is a datatype

#List
ls = ["heelo","fefe","meme"]
print(ls)
ls.reverse()
ls.sort() #Sort the list
print(ls[0:5]) #list slicing
print(ls[::2])
print(max(ls))
print(min(ls))
ls.append() #Appends number to list
ls.insert(1 , 55) #Inserts new number in list it takes first argument as index and second as number to add
ls.remove("heelo")
ls.pop()#removeS one element

#tuple
#Mutable = Can change
#Immuatable = cannot change
# ()=parenthesis
#value of tuple cannot be changed

tp= (1,2,3,5)
print(tp)

#Dictionary
# Its a key valur pairs
d1 = {}
print(type(d1))
d2={"aTUL":"burger","aasa":"asasasa","raju":{"b":"rararar","L":"mama"}}#Dict in dict
# print(d2)
d2["additem"]="additem"#Adding new item to our dictionary
print(d2)
del d2["additem"]#deletes item from dict
print(d2)
# .get = gets item from List
# .update = updates list

#SET
# ITS a data structure
s = set()
s.add()
s.add()
s.union()
s.intersection()
s.remove()

#IF ELSE
vs1 = 1
vs2 = 6
# ">" = Greater than
# "<" = Smaller than
if vs1>vs2:
  print("Bigg")
elif vs1==vs2:
  print("equal")
else:
  print("Low")

lst = ["hah","fafa","afsa"]
for i in lst:
  print(i)

#List of list
lst2=[["Hello",2],["cat",2],["dog",6000]]

for i , hello in lst2:
  print(i,"and lool,",hello)
#Taking all user names from databasae
#we can use if in for loop
#we can give @gmail.com or any thing to do with names
#we can use two for loops to iterate
for i in lst:
  for j in i:
    print(i)
    #for iterating a specific element in list or dict or tuple

#While loop
#Until Condition is true it will go on forever
i =0
while(i<45):
# print(i) #it will print till eternity
  i = i+1
  print(i)#Condition satisfies here i goes greater than 45 and loop stops
  # break Breaks the while loop

i = 0
while(True):
  if i+1<5:
    i = i+1
    continue #It will loop here till i is greater than 5 and after it will go down
    #from here program will loop untill conditon as condition goes flase loop breaks
  print(i+1, end=",")
  if(i==44):
    break
  i = i+1

  #We can use while loop to take infinte inputs from users
  #we can make game from while loop like guess the number or other
  #we can make user interface to take inputs from user
while(True):
  inp=int(input("Enter a number"))
  if inp>100:
    print("congrats you have entered number greater than 100\n")
    break #if number smaller than 100 loop goes in else and continues to ask input till its greater than 100
    
  else:
    print("try again")
    continue

#Operators
#Arithematic Operator
#Assignemnt Operator
#Comparison Operator
#Logical Operator
# Identity operator
# Bitwise operator
print(5+2)
print(5-2)
print(5*2)
print(5/2)
print(5//2)
print(5**5) #raise to
print("5 % 5") #gives raminder
# Assignent operator
x = 5  # "=" is a assignment operator
x +=7  # adds 7 in x 
print(x)
x /=7 #divides number 7 in x
#Logical operator
A =True
B=Flase
print(a and b)
print(a or b)
print (a is not b)
#Mathematical Operator
#if elements in list are in condition then it will return True

#BITWISE OPERATORS
print(0 | 1) #zero or one

#one liner code
#do it when code is short

If a>b: print("example") #condtion and print statement in one line

#Functions
#Two types of functions Userdefined and built in functions 
#User defined

def functions():
  print("Hello how are you!")

print(functions())#returns none
functions()   #prints only given statement 
##Using functions to take input

def takeinput(a,b):
  print("Hello you are taking input", a+b)

takeinput(5,8)

def average(a,b):
  avg = (a+b)/2
  print(avg)

average(334,445)
#Using return to take value from variable

def returns(a,b):
  """This function is to show return value"""
  avgg=(a+b)/2
  return avgg   #if there is no return print(v) will return none 

v=returns(112,111)
print(v)

#if we want to average on many numbers use functions made 
#we can calculate standard deviation also in ML to calculate f score probability  loggots

#There are doc strings in functions 
"""This is a doc string"""
print(returns.__doc__) #takes doc stream from functionfunctions and shows in output this helps in showing what that functions does

# Global Variables
l=10 #This is a global variable govt. money for e.g
def functionsss(n):
  l=5  #our money for e.g  Also called local variable
  m=8
  print(n,"this is me")
  print(l,m)

# if variable outside doesn't get value from local it takes from global
# if we wish to change local variable if its also a global variable then we use 'global'

functionsss("hello")
print(l)
#Global Keyword are global 'variablename'

#Nested Functions
#global varible will find here.. here
x=99
def name():
  x = 20
  def name2():
    global x
  x=88
  print("before calling name()",x)
  name2()
  print("before calling name2()",x)
  
name()

#Recurssion means using function in fucntion
def factorial(n):
  #n!=n*n-1*n-2*n-2....1
  # n!=n*(n-1)!
  fac=1
  for i in range(n):
    fac = fac*(i+1)
  return fac
  pass
numb=int(input("Enter a number"))
print(factorial(numb))

#Recursive method
def recursive(n):
  if n==1:
    return 1

  else:
    return n* recursive(n-1)
numbs=int(input("Enter a number"))
print(recursive(numbs))
# working
# 5*recursive
# 5*4*recursive
# 5*4*3*recursive
# 5*4*3*2*recursive
# 5*4*3*2*1*recursive

# Fibbonachi sequence
# Find nth fibonachi sequence

#Lamba function or anynomous function 
def add(a,b):
  return a+b
minus=lamba x, y: x-y
                        #both do sane thing
def test(x,y):
  return x-y

print(add(9,4)

#Try and Except or Exception Handling
q=int(input("Enter a number"))
a=input("Enter a number")

try:
  print("the sum is",q+a)
except Exception as e:
  print(e)

print("this should print")

#It is used in internet connected things like downloading if net gets disconnected error msg should be shown not simply exit the code

#File Reading
# "r"=open file for reading  DEFAULT MODE
# "w"= open file for writing
# "x"= Creates file if not exists
# "a"= Add more content to a file
# "t" = text mode to deal data in file as string
# 'b'=binary mode
# "+" read write
# "r+"-for both read and write
# Always close a file we opened

f=open("file.txt", "w") #we can choose mode from here as w r a...
content=f.read()
content=f.write()
as=write("Write what to add in file")
print(content)
f.close()

for line in f:
  print(line)
  #reads line in file using for loop

# readline()- reads first line of file
# readlines()- List of lines in file
# f.tell()-Tells where our file pointer is
# f.seek resets out file pointer and brings back to input e.g f.seek(10)
# append-adds string to file

# withblock
with open("filename.txt") as f: #does same work as f=open("filename.txt")
  #this also closes file so no need to close

# Modules
# if module not present install "pip install module_name" 
import random
random_number=random.randint(0,1)
rand=random.random()*100
print(rand)

lst=["star","hello","ajjtak","cartoon"]
choices=random.choice(lst)
print(choices)

# F-strings & String formatting
me="Atul"
a="This is %s"%me #Takes string from me variable %s,%me(Name of variable) not good method
print(a)
import math
hello =f"this is {me} {23*4} {math.cos(43)}"
print(hello)

# *args and **kwargs
# def function_name_print(a,b,c,d):
#   print(a,b,c,d)

# function_name_print("atul","manthan","bandar","chatre") #if we add new name(argument) it throws error

def funargs(normal,*args):# we used*names to tell name variable to go in args , we can change name after *argsnoral or *mama
  print(normal)
  for item in args:
    print(item)
  # print(args[0])
#By using args we can add more name in list and it wont throw error
names=["atul","manthan","bandar","chatre","tanmay","we can add more names"] #this list goes in args as a tuple
normal="Normal Argument"
funargs(normal, *names)
#normal first then *args its a convention

#**kwargs
def funargss(normal,**kwargs):
  for key, value in kwargs.items():
    print(f"{key} is a {value}")
kw={"rotan":"pass","road":"highway"}
funargss(normal,**kw)

#Time Module

import time
time.time()

initial = time.time()
finished=time.time()
# initial - finieshed will give program finiesd in this much time
localtime=time.asctime(time.localtime(time.time())) #time.time returns tikss
time.sleep(5) #code sleeps for time taken as argument in time.sleep("5 for 5 sec")
print(localtime)

# Virtual environment
# why its needed, for big website or data analysis tool  
# our program should not stop
# pip install virtualenv
# now we can make an env
# we have to ad every library or module in env

# Enumerate Function
l1=["hello","mewo","lol"]

i=1
for i in l1:
  if 1%2 is not 0:
    print(f"jarvis pls buy {i}")

# to do this short

for index, item in enumerate(l1):
  if index%2==0:
    print(f"jarvis pls buy {item}")

#how import works
import pandas as pd
# but from where is this module coming
# gets assign to currnt scope
# h=1 is a current scope
print(pd.__version__)
import sys
print(sys.path)

# if __name__ == __main__

import sklearn
def printhar(string):
  return f"ye string dedo{string}"

def add(num1,num2):
  return num1+num2+5


if __name__=='__main__': #Only main content will execcute it wont work in imported 
  print(printhar(" Atul"))
  oo=add(4,6)
  print(oo)
#we can use this function as import filename we created means we can create our own module
# when we use __main name it whole program will not run in other file where ti is imported
# breakdown
print(__name__)

# Join function
lst=["hello","fafaf"]
a=",".join(lst) #joins item at end of list like appending a list
print(a,"wwewe")

# Map filter Redue
numer=["3","4","6"]
for i in range(len(numer)):
  numer[i]=int(numer[i])
# numer[2]=numer+1 #to convert list item string into int
# to do this in one line
  print(i)
numer=list(map(int,numer))  

#from here MAP
def sq(a):
  return a*a
num=[1,2,3,4,5,6]
squ=list(map(sq,num))
print(squ)

def square(a):
  return a*a

def cube(a):
  return a*a*a

func=[square,cube]

#FILTERS
lists=[1,2,3,4,5,6,7,8,9]

def is_greater_5(numbs):
  return numbs>5 #will return true or false

gt =list (filter(is_greater_5,lists))
print(gt)

#Reduce
from functools import reduce

ls=[1,2,3,4]
# to add 1+2 2+3 3+4

num=reduce(lambda x,y:x+y,ls)
print(num)

# Decorators
def func():
  print("deco")
func2=func
func2()

def deck1(fubc1):
  def nowexute():
    print("doing")
    fubc1()
    print("done")
  return nowexute
# we can also use @deck1
def what():
  print("I MA god")

what=deck1(what)
what()
# its like a blueprint

# Class Object oriented programming
# classes-Template
# object-instance of class also a organized way of programming
# DRY-DO NOT REPEAT YOUR SELF
# SAVE TIME USING OOP
class student():
  pass

har=student()
har.name="Atul"
lar=student()
lar.section=34
#both are different element both take different memory locatilocatinlocatins
print(har.name,lar.section)

#Class name always capital its a good practice

# methods in class
class doit:
  def proacr(self): #self is a self vo object jiski baat ki ja rahi he
    return f"Name us {self.name} and salary {self.salary}"

# if we run method or function in self becomes "har":
  def printdetails(self):
    # we can acceses har by self
    return f"name is {self.name} "
  
har=doit()
rad=doit()

har.name="hello"
har.salary=2343
print(har.printdetails())
print(har.proacr())

# Instances
class kaam:
  no_of_leaves=8 #to change class variable only kaam. can change it not other instances
  pass


har=kaam() #this is a instance
mar=kaam() #this is a instance

har.salar="harry"

print(har.no_of_leaves)
print(har.no_of_leaves)

#Constructor gives argument to class
class emplo:
  def __init__(self,aname,asalary,arole): #self here is object being created
    self.name = aname
    self.salary=asalary
    self.role=arole

hrr=emplo("Atul",434343,"dev")

print(hrr.salary,hrr.name) #Argument goes to __init__

# Class method
class mrthods():
  no_of_leaves=9

  def __init__(self,aname,asalary,arole): #self here is object being created

    self.name = aname
    self.salary=asalary
    self.role=arole

  def printdetail(self):
    return f"{self.name},{self.salary}"

  @classmethod #DECORATROR
  def change_leaves(cls,newleaves):
    # cls is a class its instance is a object in class
    cls.no_of_leaves = newleaves
    #use of calssmethod is alternative classmetohd

#Constructor as alternative class method
#
# Class method
class mrthods():
  no_of_leaves=9

  def __init__(self,aname,asalary,arole): #self here is object being created

    self.name = aname
    self.salary=asalary
    self.role=arole

  def printdetail(self):
    return f"{self.name},{self.salary}"

  @classmethod #DECORATROR
  def change_leaves(cls,newleaves):
    # cls is a class its instance is a object in class
    cls.no_of_leaves = newleaves
    #use of calssmethod is alternative classmetohd

  @classmethod
  def from_str(cls,string):
    params= string.split("-") #it will be a list and return a list #split will work where there are dash "-" it will split from there
    return cls(params[0],params[1],params[2])#meaning mrthods

atul=mrthods("Atul",3343,"devvs")
atuls=mrthods.from_str("Atul-43434-devvs")#alternative Constructor
print(atuls.salary)

#static methods
#Constructor as alternative class method
#
# Class method
class mrthods():
  no_of_leaves=9

  def __init__(self,aname,asalary,arole): #self here is object being created

    self.name = aname
    self.salary=asalary
    self.role=arole

  def printdetail(self):
    return f"{self.name},{self.salary}"

  @classmethod #DECORATROR
  def change_leaves(cls,newleaves):
    # cls is a class its instance is a object in class
    cls.no_of_leaves = newleaves
    #use of calssmethod is alternative classmetohd

  @classmethod
  def from_str(cls,string):
    params= string.split("-") #it will be a list and return a list #split will work where there are dash "-" it will split from there
    return cls(params[0],params[1],params[2])#meaning mrthods

#ataticmethod

  @staticmethod
  def print_good(string):
    print("this is good" + string)
    return 89


atul=mrthods("Atul",3343,"devvs")
atuls=mrthods.from_str("Atul-43434-devvs")#alternative Constructor
print(atuls.salary)
atul.print_good(" atul") #for speed we use static
#we can give nay input instead of atul

# Abstraction and Encapsulation
# that “shows” only essential attributes and “hides” unnecessary information. The main purpose of abstraction is hiding the unnecessary details from the users
# Encapsulation is defined as the wrapping up of data under a single unit.

# Single inheritane
class mrthods():
  no_of_leaves=9

  def __init__(self,aname,asalary,arole): #self here is object being created

    self.name = aname
    self.salary=asalary
    self.role=arole

  def printdetail(self):
    return f"{self.name},{self.salary}"

  @classmethod #DECORATROR
  def change_leaves(cls,newleaves):
    # cls is a class its instance is a object in class
    cls.no_of_leaves = newleaves
    #use of calssmethod is alternative classmetohd

  @classmethod
  def from_str(cls,string):
    params= string.split("-") #it will be a list and return a list #split will work where there are dash "-" it will split from there
    return cls(params[0],params[1],params[2])#meaning mrthods

#ataticmethod

  @staticmethod
  def print_good(string):
    print("this is good" + string)
    return 89
  
class prgrammer(mrthods): #mrthods class ke sare gun yis class me aagaye
    def __init__(self,aname,asalary,arole,languages):
      self.name = aname
      self.salary=asalary
      self.role=arole
      self.language=languages
    def printprog(self):
      return f"programmer is {self.name}"
    pass

m = mrthods("har",3434,"dev")
s= prgrammer("shubh",43535,"dev","R")
l= prgrammer("karan","python","c++","R")
print(l.printprog())

#Multiple Inheritance
class mrthods():
  no_of_leaves=9

  def __init__(self,aname,asalary,arole): #self here is object being created

    self.name = aname
    self.salary=asalary
    self.role=arole

  def printdetail(self):
    return f"{self.name},{self.salary}"

  @classmethod #DECORATROR
  def change_leaves(cls,newleaves):
    # cls is a class its instance is a object in class
    cls.no_of_leaves = newleaves
    #use of calssmethod is alternative classmetohd

  @classmethod
  def from_str(cls,string):
    params= string.split("-") #it will be a list and return a list #split will work where there are dash "-" it will split from there
    return cls(params[0],params[1],params[2])#meaning mrthods

#ataticmethod

  @staticmethod
  def print_good(string):
    print("this is good" + string)
    return 89

#MULTI

class player:
  no_of_games= 4
  def __init__(self,name,game):
    self.name = name
    self.game = game

  def printgame(self):
    return f"Name is {self.name} game is {self.game}"

class coolprogrammer(mrthods,player):
  pass

shubham =player("shubham",["cricket"])
lara = coolprogrammer("lara",8999,"coolboy")

#multilvel inheritance
class dad:
  basketball=1

class son(dad):
  dance=1
  def isdance(self):
    return f"Yes i dance {self.dance} no of time"

class Grandson(son):
  dance=6
  def isdance(self):
    return f"jaclspn yeahh" \
    f" Yes i can dance good{self.dance} no of times"
  
darry=dad()
larry=son()
mow=Grandson()

print(mow.isdance())

# public private & protected Access specifier
# protected base class can use and also drived class no outside program can use it
class mrthods():
  no_of_leaves=9
  var=5
  _protec = 9 #this how we write protected
  __private=5
  def __init__(self,aname,asalary,arole): #self here is object being created

    self.name = aname
    self.salary=asalary
    self.role=arole

  def printdetail(self):
    return f"{self.name},{self.salary}"

  @classmethod #DECORATROR
  def change_leaves(cls,newleaves):
    # cls is a class its instance is a object in class
    cls.no_of_leaves = newleaves
    #use of calssmethod is alternative classmetohd

  @classmethod
  def from_str(cls,string):
    params= string.split("-") #it will be a list and return a list #split will work where there are dash "-" it will split from there
    return cls(params[0],params[1],params[2])#meaning mrthods
    # namemangiling

# Polymorphism means Ability to take various forms

print(5+6)
print("5"+"6")
# two string opbject and two int
# peter parker tha fir spiderman hogaya

# super() overrding()
class A:
  classcvar1="I am a varible of class A"
  def __init__(self):
    self.var1="i am in class A's Constructor"
  
class B(A):
  classvar2="i am in variale of class B"
  
a=A()
b=B()
print(b.classcvar1)

#

#Diamond Shape problem
#Confusion problem occurs above 5 multilevel classes
#java don't allow multiple inheritance
# We avoid multiple inheritace

# operator overloading and dunder methods
#dunder is a constructor
class mrthods():
  no_of_leaves=9
  var=5
  _protec = 9 #this how we write protected
  __private=5
  def __init__(self,aname,asalary,arole): #self here is object being created

    self.name = aname
    self.salary=asalary
    self.role=arole

  def printdetail(self):
    return f"{self.name},{self.salary}"

  @classmethod #DECORATROR
  def change_leaves(cls,newleaves):
    # cls is a class its instance is a object in class
    cls.no_of_leaves = newleaves
    #use of calssmethod is alternative classmetohd

  def __add__(self,other): #Dunder add operator overloading
    return self.salary +other.salary
  
  def __truediv__(self,other):
    return self.salary / other.salary

  def __repr(self):
    return f"Emplo {self.name},{self.salary}, {self.role}"

  def __str__(self):
    return f"Emplo {self.name},{self.salary}, {self.role}"
emp1=mrthods("atul",800000,"pydev")
emp2=mrthods("manthan",800000,"javadev")
print(emp1 + emp2) #this will not execute without operator overloading

# look at Mapping operator to Function

# Abstract Base class
from abc import ABCMeta, abstractmethod
class shape(metaclass=ABCMeta):
  @abstractmethod
  def printareas(self):
    return 0

class Rectangle:
  type = "rectangle"
  sides = 4

  def __init__(self):
    self.length=5
    self.breath=4

  def printarea(self):
    return self.length * self.breath

rect1=Rectangle() #write class name with a variable
print(rect1.printarea()) #write variable.methodname

# Setters and Property Decorators 
# INCOMPLETE
class Emp:
  def __init__(self,fname,lname):
    self.fname=fname
    self.lname=lname
    self.email= f"{self.fname}.{lname}@icloud.com "

  def explain(self):
    return f"this is emp is {self.fname} {self.lname}"
  @property #decorator  
  def printemail(self):
    pass

hind=Emp("hinds","sppurt")
lala=Emp("hahahs","asda")

print(hind.email) #self method used here self.email it tool fname and lname and added fstring dont init with "()" dont email() only email
print(lala.explain()) #don't forget about self write self.name self.lname not just name lname

print(hind.email)
hind.fname="US"
print(hind.email)

# Object Introspection

#Generator
# iterable - object where __iter__ or __getitem__ it defines iterator will generate iterator
# iterator is py objectt where __next()__ 
# Generator are type of generator which can only iter one time

def gen(n):
  for i in range(n):
    yield i #return fucntion ki return value, print prints on conseole,yeild will generate value on the fly and its a generator

g=gen(5)
print(g)
print(g.__next__())
print(g.__next__())
print(g.__next__())

h="Atul"


for item in h:
  print(item)

# python Comphrehensions
ls=[]
for i in range(100):
  if i%3==0:
    ls.append(i)
print(ls)
#oneliner using list comprehension

lt=[i for i in range(100) if i%3==0]
print(lt)

#dictionary compreheniom
# {0:"item 0",1:"item1"}
dict1={
    i:f" Item {i}" for i in range(5)
}
print(dict1)

#reverse dictionary
dict1={value:key for key,value in dict1.items()}
print(dict1)

#set comprehension
Dresses={dress for dress in ["dress1","dress2","dress1"]} #it will print only one string if there same string
print(Dresses)

#Generator comprehesnion
evens= (ir for ir in range(100) if i%2==0)
print(type(evens))
print(evens)
for item in evens:
  print(item)

#  Else with for loop
khana=["roti","rada","afafa"]

for item in khana:
  if item=="rotis":
    print("We serve your oder here")
    break #else only come in work after end of for loop if we use break iteration stops
else:
  print("this for loop ended properly and item was not found")

# Function Caching in python
# there is  funciotn which work take 10sec
from functools import  lru_cache
import time

@lru_cache(maxsize=3)
def some_work(n):
  time.sleep(n)#task taking some time
  return n

if __name__=='__main__':
  print("mow running some work")
  some_work(3)
  print("done...calling again")
  some_work(3)
  print("called again")
# cache=if we accses a webpage comp saves in our computer and images are saved as cache to save to show youtube thumbnails

#Else and Finally

 try:
   f=open("hello.txt")

except Exception as e:
  print(e)

finally: #used for code cleanup
  print("this will run anyway")
print("important stuff")

# Coroutines

def searcher(): #now this function is a corutune now
  import time
  book="book on discovery of ancient egyptionas"
  time.sleep(4)

  while True:
    text=(yield) #value ko on the fly generate krdo
    if text in book:
      print("your text in book")
    else:
      print("text is not in the book")

search = searcher()
next(search)
search.send("text")
input("press any key")
search.send("of")

# OS MODULE operating system
import os
# print(dir(os))
print(os.getcwd())

